<!--
 * @Author: DuYa
 * @LastEditors: DuYa
 -->

# 算法

## 算法的定义

> 算法是`解决特定问题`求解步骤的描述，在计算机中为`指令`的有限序列，并且每条指令表示一个或多个操作。
> ！

## 衡量一个算法的好坏

一个算法的好坏主要是时间复杂度和空间复杂度来决定的

## 算法的特性

> 输入、输出、有穷性、确定性和可行性

> 在算法中，一个算法可以有零个或多个输入，也就是说算法的输入可以是零个，怎么说呢？举个栗子 🌰 吧

```
console.log("Hello world") // 这个打印数据的栗子🌰没有输入，只有对"Hello world"这个字符串的输出
```

对于算法的输出来说，输出`一定`不能为零。算法是用来解决问题的，问题都没有，那写出来的东西能叫算法吗？“输出数量为零”这个想法就跟算法的定义相矛盾了，
所以说算法的输出铁定的不为零。  
算法的有穷性体现在程序的算法执行到最后一定能够做到的出结论，如果写的算法执行到最后一直跑 🏃，那这个算法能输出东西吗？  
算法的确定性表现为算法不可能具有二义性。比方说，你的面前有两座高山 🗻🗻，一座高山 🗻 在你的左侧，一座高山 🗻 在你的右侧。你能同一时间站在两座高山 🗻 上吗？
这显然是不现实的。  
算法的可行性具体表现为，coder 写出来的算法,一定能解决当前要处理的问题，而不是这样写“好帅呀”。然并卵，写出来的东西什么都做不了，写的再规范都是纸老虎 🐯！

## 算法的设计要求

正确性、可读性、健壮性、高效率和低存储量需求。

## 算法效率的度量方法

### 事后统计方法

> 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

### 事前分析估算法

> 在计算机程序编制前，依据笼统也比较实际的统计方法对算法进行耗时估算。

经过分析，我们发现，程序在计算机上运行所消耗的时间主要取决于一下几个因素：

1、算法采用的策略、方法  
2、编译产生的代码质量  
3、问题的输出规模  
4、机器执行指令的速度

## 时间复杂度

作为评价一个算法优劣最多的`凭证`, 时间复杂度具有自己的一套依据：O 阶。（大 O 表示法）

```
推导O阶的方法：
1、用常数1取代运行时间中的所有常数。如 1 + 1 + 2 + 3 + .... + n（常数） 时间复杂度为O(1)
2、去掉除常数后，保留最大的变量。 如最大的是那就是 O(n)；如果是 n^2 那就是O(n^2) 以此类推...

常见的时间复杂度的从小到大的排序是：
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
```

## 空间复杂度

空间复杂度是执行算法的空间成本，也是用大 O 表示法

## 最坏情况和平均情况

很多情况，大多数算法更乐意用空间换取时间 😄
